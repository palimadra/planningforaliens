---
layout: resource
style: angular/animate.css
external:
- //ajax.googleapis.com/ajax/libs/angularjs/1.3.10/angular.min.js
- //ajax.googleapis.com/ajax/libs/angularjs/1.3.10/angular-animate.min.js
javascript: directives.js
title: "Animate your Angular App by @sfioritto"
date: "2014-12-16T00:00:00-06:00"
---

<div class="top">
  <div class="title">
    <h1>
      <span>Animate</span>
      <span>Your</span>
      <span>Angular</span>
      <span>Application</span>
    </h1>
    <figure>
      <img src="/images/rocket.png" />
    </figure>
  </div>

  <div class="email-form-box">
    <h2>
      (Brought to you by the <a
      href="http://training.planningforaliens.com/angular/">Angular
      Escape Plan</a>. Try a few Angular lessons for free.)
    </h2>
    <form action="https://www.getdrip.com/forms/4460229/submissions"
          method="post" target="_blank"
          data-drip-embedded-form="3061"
          class="email-form">
      <input type="email" name="fields[email]" value=""
             class="required email"  placeholder="Email address"/>
      <input type="submit" 
             name="submit" 
             value="Start your free lessons"
             data-drip-attribute="sign-up-button" 
             class="button"/>
    </form>
  </div><!-- end email form -->
</div><!-- end top -->

<div class="body" ng-app="animations">

  <p>
    When an Angular app updates the DOM, the default experience
    is a little ... janky. Angular dumps the elements into the view with no
    transition. 
  </p>
  <p>
  So you decide to add some animations to improve the user
  experience, and it turns out Angular has a module and a service just
    for animations.
  </p>

  <p>And maybe it's not exactly what you expected.</p>
  
  <h2>Understanding $animate and the ngAnimate module</h2>
  
  <p>
    In a non-Angular Javascript app, you write the code that updates
    the DOM, so while you're writing that code you sprinkle in some
    custom animations, NBD. But you don't find yourself mucking around
    in the DOM quite as often in Angular apps, especially if you are
    sticking to mostly built-in directives.
  </p>
  <p>
  It's not the Angular Way. So what's a developer to do.
  </p>
  <h3>
    How would animations work in a web application if you weren't using
  Angular?
  </h3>
  
  <p>
    You would:
  </p>

  <ul>
    <li>Define your starting and end styles</li>
    <li>Add or change an element and set it to the starting style</li>
    <li>Animate to the end style</li>
  </ul>
  <p>
  And you're either doing this with Javascript or CSS.
  </p>
  <p>
    When you add animations to your Angular application, you follow this
    pattern, but in a very Angular-y way that completely decouples your
animation code from your directive code.
  </p>

  <h3>This is a good thing.</h3>
  <p>
    Angular's built-in directives are pre-wired for animations. What
    that means is you get access to animation "events" which you can
    hook into with either CSS classes or Javascript code.
  </p>
  <p>
    That probably means very little to you right now, but stay with
    me, by the end of this article it should make sense. The upside is
  you can create your own custom directives and then let end users of
  those directives define their own animations.
  </p>
  <h3>Code reuse FTW.</h3>
  <p>
  This is exactly how Angular designed its own directives. This way
  developers and designers get to chooose animations, they aren't
  predefined by Angular. And you can create the animations any way you
  like, with CSS transitions or animations or any Javascript libary.
  </p>
  <h2>Build your own directive</h2>
  <p>
    It's easier to understand how all the pieces fit together if you build
    and animate a simple custom directive you write yourself. Then you can circle back and
    understand <em>exactly</em> what's happening in the built-in directives.
  </p>
  <p>
    Here is a simple directive for hiding an element with no support for animations:
  </p>
  
  {% highlight javascript %}
app.controller("example1", function($scope){
    $scope.awesome = false;
});
  
app.directive("myHide", function(){
    return {
        restrict: 'A',
        link: function(scope, elem, attrs){
            scope.$watch(attrs.myHide, function(value){
                if (value) {
                    elem.addClass("hide");
                } else {
                    elem.removeClass("hide");
                }
            });
        }
    };
});
  {% endhighlight %}
  
  <p>
    The myHide directive watches an expression, (in this case the
    value of 'awesome'), and when the expression
    evaluates as truthy, adds a class to the element and removes it when
    it's false. The class sets display to none, so the myHide element is
    hidden when the expression is truthy.
  </p>
  
  {% highlight html %}
  <div class="myHideExample" ng-controller="example1">
    <div class="message">
      <p my-hide="awesome">Hide this text if awesome</p>
    </div>
    <button class="button" ng-click="awesome = !awesome">Toggle awesomeness</button>
  </div>  
  {% endhighlight %}
  
  <div class="myHideExample" ng-controller="example1">
    <div class="message">
      <p my-hide="awesome">Hide this text if awesome</p>
    </div>
    <button class="button" ng-click="awesome = !awesome">Toggle awesomeness</button>
  </div>

  <p>
    This works, but there is no transition, it just pops in and out of existence.
  </p>

  <h2>Add an animation to this directive without $animate</h2>
  <p>
  By the end of this section, you'll have a pretty good understanding
  of $animate without actually using it.
  </p>
  <p>
  The animation for myHide will fade the opacity of the element
  from 1 to 0, (and back when the state is toggled). At the end of the
  animation, display should be set to none.
  </p>
  <p>
  And this presents an interesting problem, because you can't set
  display to none until the end of the animation &mdash;
  otherwise the whole animation is running while the element isn't
  visible. Oops. So you will need one class to represent the
  transition/animation and another class to set display to none after
  everything is done.
  </p>
  
  <h3>The CSS so far would look like ... </h3>
  
  {% highlight css %}
.hide {
    display: none;
}
.hide-add {
    transition: opacity 1s;
    //don't strictly need this ..
    opacity: 0;
}
  {% endhighlight %}
  
  <p>And then a few lines of Javascript in the directive to add the classes at the
  right time</p>
  {% highlight javascript %}
// add this first to start the animation
elem.addClass("hide-add");
setTimeout(function() {
    // add the hide class after animation is finished
    elem.addClass("hide");
    // clean up
    elem.removeClass("hide-add");
}, 1000);
  {% endhighlight %}
  <p>
  So the .hide-add class adds the transition and the final value, and
  then after the transition is done the .hide class is added which
  sets display to none.
  </p>
  
  <h3>The CSS for removing and animating the hide class</h3>
  
    {% highlight css %}
.hide-remove {
    transition: opacity 1s;
    opacity: 0;
}
.hide-remove-active {
    opacity: 1;
}
  {% endhighlight %}

  
  <p>
  To animate when the .hide class is removed, the first step is to set
  the opacity to 0. What would happen if you removed the hide class
  without setting the opacity to 0? The element
  would just pop in with no animation at all. 
  </p>
  <p>
  In order to create a transition from an opacity of 0 to 1, you need
  another class to define the end state. So one class will define the
  start state plus transition/animation and another will define the
  end state to animate to.
  </p>
  <p>
The Javascript is almost exactly the same as adding the .hide class,
  but there are now two classes.
  </p>
{% highlight js %}
elem.addClass("hide-remove");
elem.removeClass("hide");
  // cause a reflow
elem[0].offsetHeight;
elem.addClass("hide-remove-active");
setTimeout(function(){
    elem.removeClass("hide-remove");
    elem.removeClass("hide-remove-active");
}, 1000);
{% endhighlight %}

<p>
The line between removing .hide and adding .hide-remove-active causes
  a reflow. Without it, the browser doesn't apply the transition and
  the element just pops in.
</p>
<h3>And the final result ...</h3>
  <div class="myHideExample" ng-controller="example1">
    <div class="message">
      <p my-hide-animated="awesome">Hide this text if awesome</p>
    </div>
    <button class="button" ng-click="awesome = !awesome">Toggle awesomeness</button>
  </div>

  <h2>And now you know how $animate and ngAnimate module work</h2>

  <p>
  
  </p>
  
  <p>
    - set start style, add element, add end style and transition
    -but now this directive is not very reusable, everyone has to do the same animations, you want animations completely decoupled
    - what if we just added special css classes at the right times instead? that's what $animate does for you
    - include ngAnimate module
    - quick intro $animate. list methods. each of those does the thing, (like add/remove element) AND adds special classes or triggers your javascript animation at the right time
      - replace example code with $animate calls
      - rewrite css to use angular default classes
      - want to use javascript animation instead?
      -- here's how you trigger it with $animate
      -- here's how you define it
  </p>
  
  <p>
    - all built-in directives use $animate like this, so you can define your own animations
    - look at code for ngShow
    - so for ngShow, you just hook in using their CSS classes
  </p>
  
  <p>
    Another example? Navigating on this page.
    - how it works
    - code is on github
  </p>
  
{% include angular-escape-form.html %}
</div><!-- end body -->

